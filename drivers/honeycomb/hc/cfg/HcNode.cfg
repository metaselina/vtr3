#! /usr/bin/env python

# Unpublished Work Copyright 2019 Waymo LLC.  All rights reserved.
# Waymo Proprietary and Confidential - Contains Trade Secrets
#
# This is the proprietary software of Waymo LLC ("Waymo") and/or its licensors,
# and may only be used, duplicated, modified or distributed pursuant to the
# terms and conditions of a separate, written license agreement executed
# between you and Waymo (an "Authorized License"). Except as set forth in an
# Authorized License, Waymo grants no license (express or implied), right to
# use, or waiver of any kind with respect to the Software, and Waymo expressly
# reserves all rights in and to the Software and all intellectual property
# rights therein. IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO
# USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY WAYMO AND
# DISCONTINUE ALL USE OF THE SOFTWARE.
#
# Except as expressly set forth in the Authorized License:
#
# 1. This software includes trade secrets of Waymo, and you shall use all
# reasonable efforts to protect the confidentiality thereof.  You shall use
# this software only in connection with your authorized use of Waymo products.
#
# 2. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, WAYMO PROVIDES THE
# WAYMO SOFTWARE ON AN "AS IS" AND "AS AVAILABLE" BASIS WITH ALL FAULTS AND
# WITHOUT ANY REPRESENTATIONS OR WARRANTIES OF ANY KIND.  WAYMO EXPRESSLY
# DISCLAIMS ALL WARRANTIES, WHETHER IMPLIED, STATUTORY OR OTHERWISE, INCLUDING
# IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR
# PARTICULAR PURPOSE OR ARISING FROM COURSE OF PERFORMANCE, COURSE OF DEALING
# OR USAGE OF TRADE.  SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF CERTAIN
# WARRANTIES, REPRESENTATIONS OR CONDITIONS, THE LIMITATION OR EXCLUSION OF
# IMPLIED WARRANTIES, LIMITATIONS ON HOW LONG AN IMPLIED WARRANTY MAY LAST OR
# EXCLUSIONS OR LIMITATIONS FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, SO SOME OF
# THE ABOVE LIMITATIONS MAY NOT APPLY IN FULL TO YOU, AND WAYMO'S LIABILITY
# SHALL BE LIMITED TO THE EXTENT SUCH LIMITATIONS ARE PERMITTED BY LAW.
#
# 3. TO THE MAXIMUM EXTENT PERMITTED UNDER APPLICABLE LAW, IN NO EVENT WILL
# WAYMO OR ITS LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL,
# INCIDENTAL, EXEMPLARY, PUNITIVE OR CONSEQUENTIAL DAMAGES OF ANY KIND ARISING
# OUT OF OR IN CONNECTION WITH THE WAYMO SOFTWARE, REGARDLESS OF THE FORM OF
# ACTION, WHETHER IN CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR
# OTHERWISE, EVEN IF WAYMO HAS BEEN ADVISED OR IS OTHERWISE AWARE OF THE
# POSSIBILITY OF SUCH DAMAGES. THE FOREGOING LIMITATIONS, EXCLUSIONS, AND
# DISCLAIMERS WILL APPLY TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW,
# EVEN IF ANY REMEDY FAILS ITS ESSENTIAL PURPOSE.

"""Generate dynamic reconfiguration header for HC node."""

from dynamic_reconfigure import parameter_generator_catkin as pg

PACKAGE = "hc"

gen = pg.ParameterGenerator()

# If always setting a parameter on any config change is a no-op (or very fast),
# then make it a FAST_CHANGE.  For more expensive config changes, define a
# new change level.
(FAST_CHANGE, PITCH_TABLE_CHANGE,
 CALIBRATION_CHANGE) = (1 << x for x in range(3))
levels = gen.enum([
    gen.const("Fast_Change", pg.int_t, FAST_CHANGE, "Fast Change"),
    gen.const("Pitch_Table_Change", pg.int_t, PITCH_TABLE_CHANGE,
              "Pitch Table Change"),
    gen.const("Calibration_Change", pg.int_t, CALIBRATION_CHANGE,
              "Calibration Change"),
], "Levels enum")

gen.add("frame_id", pg.str_t, FAST_CHANGE, "Frame ID for the point cloud", "hc")
gen.add("imu_frame_id", pg.str_t, FAST_CHANGE, "Frame ID for the IMU", "hc_imu")
gen.add("fov", pg.double_t, FAST_CHANGE,
        "Set the horizontal field of view in degrees", 210, 1, 360)
gen.add("direction", pg.double_t, FAST_CHANGE,
        "Set center of the horizontal field of view in degrees", 0, -180, 180)
gen.add("spin_frequency", pg.double_t, FAST_CHANGE,
        "The spinning frequency in Hz", 10, 5, 15)
gen.add("vertical_scan_frequency", pg.double_t, FAST_CHANGE,
        "The frequency of vertical laser sweeps in Hz", 3 * 496.18, 3 * 492.5,
        3 * 500)
gen.add(
    "scans_per_point_cloud", pg.int_t, FAST_CHANGE, "Number of vertical laser "
    "scans combined into one point cloud message (0 means a full spin)", 0, 0,
    1000)

# return_mode_list used in two enums, return_mode_enum and image_return_enum
return_mode_list = [
    gen.const("All_Returns", pg.int_t, 0, "All Returns"),
    gen.const("First_Return", pg.int_t, 1, "First Return"),
    gen.const("Last_Return", pg.int_t, 2, "Last Return"),
    gen.const("Strongest_Return", pg.int_t, 3, "Strongest Return"),
]
return_mode_enum = gen.enum(return_mode_list, "Which return to use")
gen.add(
    "return_mode",
    pg.int_t,
    FAST_CHANGE,
    "Return mode for point cloud",
    0,
    edit_method=return_mode_enum)

pitch_enum = gen.enum([
    gen.const("Default", pg.int_t, 0, "Default pitch table"),
    gen.const("Full_Fov_High_Res", pg.int_t, 1, "High resolution pitch table"),
    gen.const("Custom", pg.int_t, 2, "Custom"),
], "Pitch table enum")

gen.add(
    "pitch_table",
    pg.int_t,
    PITCH_TABLE_CHANGE,
    "Pitch table to use",
    0,
    edit_method=pitch_enum)
gen.add(
    "custom_pitch_table", pg.str_t, PITCH_TABLE_CHANGE,
    "Specify custom pitch table as a list of comma-separated pitch angles (in degrees)",
    "")
gen.add("interlaced", pg.bool_t, PITCH_TABLE_CHANGE, "Interlace vertical scans",
        False)
sides_enum = gen.enum([
    gen.const("None", pg.int_t, 0, "Neither side"),
    gen.const("Front", pg.int_t, 1, "Front side only"),
    gen.const("Back", pg.int_t, 2, "Back side only"),
    gen.const("Both", pg.int_t, 3, "Both sides"),
], "Sides enum")
gen.add(
    "sides",
    pg.int_t,
    FAST_CHANGE,
    "Specify which side to fire the laser out of.",
    3,
    edit_method=sides_enum)
gen.add(
    "compute_normals",
    pg.int_t,
    FAST_CHANGE,
    "Enable normal computation for point cloud",
    0,
    edit_method=sides_enum)
gen.add("drop_noise_returns", pg.bool_t, FAST_CHANGE, "Drop noise returns",
        True)
gen.add("publish_normal_markers", pg.bool_t, FAST_CHANGE,
        "Publish normals as visualization Markers", False)
gen.add("publish_imu_data", pg.bool_t, FAST_CHANGE, "Publish IMU data", True)
gen.add("publish_spherical_coords", pg.bool_t, FAST_CHANGE,
        "Add spherical coordinates to the point cloud", True)
gen.add("publish_beam_side", pg.bool_t, FAST_CHANGE,
        "Add laser emission side field to point cloud (front: 0, back:1)", True)
gen.add("publish_raw_intensity", pg.bool_t, FAST_CHANGE,
        "Add raw intensity field to the point cloud", True)
gen.add("publish_pulse_width", pg.bool_t, FAST_CHANGE,
        "Add pulse width field to the point cloud", True)
gen.add("publish_return_index", pg.bool_t, FAST_CHANGE,
        "Add point return index field to the point cloud", True)
gen.add("publish_return_state", pg.bool_t, FAST_CHANGE,
        "Add point return state to the point cloud", True)

scan_image = gen.add_group("scan image")

image_bits_enum = gen.enum([
    gen.const("Mono8", pg.int_t, 8, "Mono8"),
    gen.const("Mono16", pg.int_t, 16, "Mono16"),
], "Mono Image bits per pixel enum")
scan_image.add(
    "si_mono_bits",
    pg.int_t,
    FAST_CHANGE,
    "Bits per pixel of mono image",
    16,
    edit_method=image_bits_enum)

# disables 0: All Returns from return_mode_list
image_return_enum = gen.enum(return_mode_list[1:], "Which return to use")
scan_image.add(
    "si_return",
    pg.int_t,
    FAST_CHANGE,
    "Return to use for image",
    3,
    edit_method=image_return_enum)

gen.add("azimuth_adjustment_delta", pg.double_t, CALIBRATION_CHANGE,
        "Azimuth Adjustment (in degrees)", 0, -5, 5)
gen.add("elevation_adjustment_delta", pg.double_t, CALIBRATION_CHANGE,
        "Elevation Adjustment (in degrees)", 0, -5, 5)
gen.add("distance_offset_delta", pg.double_t, CALIBRATION_CHANGE,
        "Distance Offset (in meters)", 0, -1, 1)
gen.add("comparator_threshold_delta", pg.double_t, CALIBRATION_CHANGE,
        "Comparator Threshold", 0, -10, 10)

exit(gen.generate(PACKAGE, "hc_node", "HcNode"))
