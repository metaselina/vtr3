/////////////////////////////////////////////////////////////////////////////
/// Semaphore implementation.  Various flavours of semaphores for all your
/// concurrency needs!
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include <condition_variable>
#include <mutex>

namespace vtr {
namespace common {

/////////////////////////////////////////////////////////////////////////////
/// @brief Allows sharing of a resource between several threads, without
//         central coordination.
/////////////////////////////////////////////////////////////////////////////
class semaphore {
 public:
  /////////////////////////////////////////////////////////////////////////////
  /// @brief Default constructor
  /// @param count The initial semaphore count
  /////////////////////////////////////////////////////////////////////////////
  explicit semaphore(size_t count = 1);

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Release the semaphore, allowing another thread to acquire it
  /////////////////////////////////////////////////////////////////////////////
  virtual void release();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Acquire the semaphore.  Blocks if it is not available (count zero)
  /////////////////////////////////////////////////////////////////////////////
  virtual void acquire();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Try to acquire the semaphore.  Returns false immediately if the
  ///        semaphore is not available.
  /////////////////////////////////////////////////////////////////////////////
  virtual bool try_acquire();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Get the count of the semaphore.  NOTE: value is "approximate", but
  ///        this function never blocks.
  /////////////////////////////////////////////////////////////////////////////
  inline size_t get_value() const { return count_; }

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Get the count of the semaphore
  /////////////////////////////////////////////////////////////////////////////
  inline size_t get_value() {
    lock_t lck(mtx_);
    return count_;
  }

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Mutexes and conditions are not copyable, so neither is this.
  /////////////////////////////////////////////////////////////////////////////
  semaphore(const semaphore&) = delete;
  semaphore& operator=(const semaphore&) = delete;

 protected:
  typedef std::unique_lock<std::mutex> lock_t;

  std::mutex mtx_;
  std::condition_variable cv_;
  size_t count_;
};

/////////////////////////////////////////////////////////////////////////////
/// @brief As semaphore, but with an upper bound
/////////////////////////////////////////////////////////////////////////////
class bounded_semaphore : public virtual semaphore {
 public:
  /////////////////////////////////////////////////////////////////////////////
  /// @brief Default constructor
  /// @param count The initial semaphore count
  /// @param bound The maximum semaphore count
  /////////////////////////////////////////////////////////////////////////////
  bounded_semaphore(size_t count = 1, size_t bound = 1);

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Release the semaphore, allowing another thread to acquire it. This
  ///        may block until acquire() is called elsewhere when count == bound.
  /////////////////////////////////////////////////////////////////////////////
  virtual void release();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Acquire the semaphore.  Blocks if it is not available (count zero)
  /////////////////////////////////////////////////////////////////////////////
  virtual void acquire();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Try to acquire the semaphore.  Returns false immediately if the
  ///        semaphore is not available.
  /////////////////////////////////////////////////////////////////////////////
  virtual bool try_acquire();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Try to release the semaphore.  Returns false immediately if the
  ///        semaphore is at the bound.
  /////////////////////////////////////////////////////////////////////////////
  virtual bool try_release();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Mutexes and conditions are not copyable, so neither is this.
  /////////////////////////////////////////////////////////////////////////////
  bounded_semaphore(const bounded_semaphore&) = delete;
  bounded_semaphore& operator=(const bounded_semaphore&) = delete;

 protected:
  size_t bound_;
  std::condition_variable cv_reverse_;
};

/////////////////////////////////////////////////////////////////////////////
/// @brief As semaphore, but with extra notification to allow waiting
/////////////////////////////////////////////////////////////////////////////
class joinable_semaphore : public virtual semaphore {
 public:
  /////////////////////////////////////////////////////////////////////////////
  /// @brief Default constructor
  /// @param count The initial semaphore count
  /////////////////////////////////////////////////////////////////////////////
  explicit joinable_semaphore(size_t count = 1);

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Release the semaphore, allowing another thread to acquire it
  /////////////////////////////////////////////////////////////////////////////
  virtual void release();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Acquire the semaphore.  Blocks if it is not available (count zero)
  /////////////////////////////////////////////////////////////////////////////
  virtual void acquire();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Try to acquire the semaphore.  Returns false immediately if the
  ///        semaphore is not available.
  /////////////////////////////////////////////////////////////////////////////
  virtual bool try_acquire();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Wait for the semaphore to acheive a specific value
  /////////////////////////////////////////////////////////////////////////////
  virtual void wait(size_t val = 0);

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Mutexes and conditions are not copyable, so neither is this.
  /////////////////////////////////////////////////////////////////////////////
  joinable_semaphore(const joinable_semaphore&) = delete;
  joinable_semaphore& operator=(const joinable_semaphore&) = delete;

 protected:
  std::condition_variable wait_;
};

/////////////////////////////////////////////////////////////////////////////
/// @brief As semaphore, but with both an upper bound and extra notification
//         to allow waiting
/////////////////////////////////////////////////////////////////////////////
class bounded_joinable_semaphore : public bounded_semaphore,
                                   public joinable_semaphore {
 public:
  /////////////////////////////////////////////////////////////////////////////
  /// @brief Default constructor
  /// @param count The initial semaphore count
  /////////////////////////////////////////////////////////////////////////////
  explicit bounded_joinable_semaphore(size_t count = 1, size_t bound = 1);

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Release the semaphore, allowing another thread to acquire it
  /////////////////////////////////////////////////////////////////////////////
  virtual void release();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Acquire the semaphore.  Blocks if it is not available (count zero)
  /////////////////////////////////////////////////////////////////////////////
  virtual void acquire();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Try to acquire the semaphore.  Returns false immediately if the
  ///        semaphore is not available.
  /////////////////////////////////////////////////////////////////////////////
  virtual bool try_acquire();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Try to release the semaphore.  Returns false immediately if the
  ///        semaphore is at the bound.
  /////////////////////////////////////////////////////////////////////////////
  virtual bool try_release();

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Wait for the semaphore to acheive a specific value
  /////////////////////////////////////////////////////////////////////////////
  virtual void wait(size_t val = 0);

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Mutexes and conditions are not copyable, so neither is this.
  /////////////////////////////////////////////////////////////////////////////
  bounded_joinable_semaphore(const bounded_joinable_semaphore&) = delete;
  bounded_joinable_semaphore& operator=(const bounded_joinable_semaphore&) =
      delete;
};

/////////////////////////////////////////////////////////////////////////////
/// @brief Class to acquire and release a semaphore using the RAI paradigm
/////////////////////////////////////////////////////////////////////////////
template <class sem_t>
class semaphore_guard {
 public:
  /////////////////////////////////////////////////////////////////////////////
  /// @brief Default constructor acquires the semaphore (blocking)
  /////////////////////////////////////////////////////////////////////////////
  explicit semaphore_guard(sem_t& semaphore) : semaphore_(semaphore) {
    semaphore_.acquire();
  }

  /////////////////////////////////////////////////////////////////////////////
  /// @brief If the semaphore is already owned by this thread, construct
  ///        without acquiring.
  /////////////////////////////////////////////////////////////////////////////
  semaphore_guard(sem_t& semaphore, std::adopt_lock_t)
      : semaphore_(semaphore) {}  // calling thread already holds the semaphore

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Destructor releases the semaphore (blocking for bounded semaphore)
  /////////////////////////////////////////////////////////////////////////////
  ~semaphore_guard() { semaphore_.release(); }

  /////////////////////////////////////////////////////////////////////////////
  /// @brief Semaphores are not copyable, and neither is this.
  /////////////////////////////////////////////////////////////////////////////
  semaphore_guard(const semaphore_guard&) = delete;
  semaphore_guard& operator=(const semaphore_guard&) = delete;

 private:
  sem_t& semaphore_;
};

}  // namespace common
}  // namespace vtr